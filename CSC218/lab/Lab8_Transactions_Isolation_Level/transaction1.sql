-- ISOLATION LEVEL
-- ANSI SQL -> DB2 -> Problem
-- 4.) Serializable -> Repeatable Read (RR) -> Phantom Read
-- 3.) Repeatable read -> Read Stability (RS) -> Incorrect Sum
-- 2.) Read committed -> Cursor Stability (CS) -> Dirty Read
-- 1.) Read uncommitted -> Uncommitted Read (UR) -> Lost Update

SELECT * FROM EMPLOYEE WHERE EMPNO = '000020';

-- Example 0
-- Commit -> Finish the transaction -> Change the state for db
UPDATE EMPLOYEE SET SALARY = 20000 WHERE EMPNO = '000020';
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO = '000020';
COMMIT;

-- Example 0.2
    -- Rollback -> Reset the data to previous state
UPDATE EMPLOYEE SET SALARY = 30000 WHERE EMPNO = '000020';
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO = '000020';
ROLLBACK;

-- Example 0.3
UPDATE EMPLOYEE SET SALARY = 40000 WHERE EMPNO = '000020';
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO = '000020';
COMMIT;
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO = '000020';
ROLLBACK; -- Rollback after commit is change nothing.
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO = '000020';

-- 1.) Read uncommitted -> Uncommitted Read (UR) -> Lost Update
-- Example 1
UPDATE EMPLOYEE SET SALARY = 20000 WHERE EMPNO = '000020';
COMMIT;
-- Now salary is 20,000
SET CURRENT ISOLATION UR;
COMMIT;
UPDATE EMPLOYEE SET SALARY = 30000 WHERE EMPNO = '000020';
COMMIT;
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO = '000020';

UPDATE EMPLOYEE SET SALARY = 70000 WHERE EMPNO = '000020';
COMMIT;

-- Example 1.1
UPDATE EMPLOYEE SET SALARY = 20000 WHERE EMPNO = '000020';
SET CURRENT ISOLATION UR;
COMMIT;

UPDATE EMPLOYEE SET SALARY = 50000 WHERE EMPNO = '000020';
COMMIT;
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO = '000020';


UPDATE EMPLOYEE SET SALARY = 60000 WHERE EMPNO = '000030';
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO IN ('000030', '000020');
COMMIT;

-- 2.) Read committed -> Cursor Stability (CS) -> Dirty Read
-- Allow only to read/write only after the update statement is committed.
-- Example 2
SET CURRENT ISOLATION CS;
COMMIT;
--- 70,000 for '000020', 60,000 for '000030'
UPDATE EMPLOYEE SET SALARY = 10000 WHERE EMPNO = '000020';
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO IN ('000030', '000020');
COMMIT;


-- 3.) Repeatable read -> Read Stability (RS) -> Incorrect Sum
-- Lock the records when SELECT is run until committed.
-- Example 3
UPDATE EMPLOYEE SET SALARY = 20000 WHERE EMPNO = '000020';
UPDATE EMPLOYEE SET SALARY = 30000 WHERE EMPNO = '000030';
COMMIT;
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO IN ('000030', '000020');

SET CURRENT ISOLATION RS;
COMMIT;
-- DB already lock two record below when we run below SQL command
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO IN ('000030', '000020');
COMMIT;
-- This below statement cannot run because T2 is not committed yet.
SELECT FIRSTNME, LASTNAME, SALARY FROM EMPLOYEE WHERE EMPNO IN ('000030', '000020');
COMMIT;


-- 4.) Serializable -> Repeatable Read (RR) -> Phantom Read
-- Example 4
SELECT * FROM EMPLOYEE WHERE FIRSTNME LIKE  'S%';
SET CURRENT ISOLATION RR;
COMMIT;

SELECT * FROM EMPLOYEE WHERE FIRSTNME LIKE  'S%';
COMMIT;

-- Example 4.2 DELETE
SELECT * FROM EMPLOYEE WHERE FIRSTNME LIKE  'S%';
COMMIT;

-- Example 4.3 READ and READ does not create conflict
SELECT * FROM EMPLOYEE WHERE FIRSTNME LIKE  'S%';
COMMIT;